// graphs.controller.js
(function ()
{
  'use strict';

  angular
    .module('app.cctool.graphs')
    .controller('GraphsController', GraphsController);

  GraphsController.$inject = ['graphs', '$log', '$scope', '$mdDialog', '$mdToast', '$mdMedia', '$state', '$stateParams', '$element', '$window', '$filter', 'api', 'mdThemeColors', 'settingsService'];

  /** @ngInject */
  function GraphsController(graphs, $log, $scope, $mdDialog, $mdToast, $mdMedia, $state, $stateParams, $element, $window, $filter, api, mdThemeColors, settingsService)
  {
    /* jshint validthis: true */
    var vm                 = this;

    // Data
    vm.title               = 'GraphsController';
    vm.activeSettings      = settingsService.activeSettings;
    vm.graphs              = graphs.results ? graphs.results : [];
    vm.selectedGraphIndex  = 0;
    vm.selectedConfIndex   = {};
    vm.networks            = {};
    vm.reloadGraph         = {};
    vm.graphProgressLinear = {active:false, mode:'', value:'', bufferValue:''};
    vm.nodesPanelData      = undefined;

    var toastPosition      = 'bottom left';
    $scope.$mdMedia        = $mdMedia;
    $scope.mdThemeColors   = mdThemeColors;

    // Methods
    vm.saveAsImage            = saveAsImage;
    vm.exportCSV              = exportCSV;
    vm.exportJSON             = exportJSON;
    vm.enableOption           = enableOption;
    vm.isControlNode          = isControlNode;
    vm.onGraphTabSelected     = onGraphTabSelected;
    vm.drawGraph              = drawGraph;
    vm.onNewGraph             = onNewGraph;
    vm.onGraphAnalyse         = onGraphAnalyse;
    vm.onGraphEdit            = onGraphEdit;
    vm.onGraphDuplicate       = onGraphDuplicate;
    vm.onGraphLayout          = onGraphLayout;
    vm.onGraphReset           = onGraphReset;
    vm.onGraphRemove          = onGraphRemove;
    vm.onGraphReload          = onGraphReload;
    vm.goFullscreenGraph      = goFullscreenGraph;
    vm.showGraphKey           = showGraphKey;
    vm.showGraphHelp          = showGraphHelp;
    vm.showGraphCompare       = showGraphCompare;
    vm.constructNodeData      = constructNodeData;
    vm.goFullscreenStems      = goFullscreenStems;
    vm.showStemsKey           = showStemsKey;
    vm.showStemsHelp          = showStemsHelp;

    init();

    //////////

    // ** GLOBAL

    function init()
    {
      if (_.isEmpty(vm.graphs))
      {
        vm.hasNoGraphs = true;
      }
      else
      {
        watchSettings();
      }
      
      // If from compare state and graphs is not given as a parameter,
      // jump to the graphs page.
      if ($state.is('app.cctool_graphs_compare'))
      {
        if ($stateParams.graphs)
        {
          vm.graphs = $stateParams.graphs;
        }
        else
        {
          $state.go('app.cctool_graphs');
        }
      }
      for (var i in vm.graphs)
      {
        vm.selectedConfIndex[vm.graphs[i].id] = 0;
        vm.networks[vm.graphs[i].id] = undefined;
        vm.reloadGraph[vm.graphs[i].id] = false;
      }
    }

    function watchSettings()
    {
      $scope.$watch('vm.activeSettings',
        function(newVal, oldVal)
        {
          sortGraphs(newVal.graphsSorting);
        },
        true)
    }

    function sortGraphs(sortItem)
    {
      vm.graphs = $filter('orderBy')(vm.graphs, sortItem.value, sortItem.reversed);
    }

    function saveAsImage()
    {
      var graph = vm.graphs[vm.selectedGraphIndex];
      if (graph.graphanalysed)
      {
        var confid  = vm.selectedConfIndex[graph.id];
        var graphTabElem = angular.element( document.querySelector('#tab-'+graph.id+'-'+confid) );
      }
      else
      {
        var graphTabElem = angular.element( document.querySelector('#tab-'+graph.id) );
      }

      var canvasTitle    = graph.title;
      var canvasSubtitle = 'Generated by CCTool (cctool.herokuapp.com)';

      var canvasElem = graphTabElem.find('canvas')[0];
      var ctx = canvasElem.getContext('2d');
      ctx.font = '18px Roboto';
      ctx.fillText(canvasTitle,10,30);
      ctx.font = '10px Roboto';
      ctx.fillText(canvasSubtitle,10,40);
      var imgUrl = canvasElem.toDataURL('image/png').replace(/^data:image\/[^;]*/, 'data:application/octet-stream');
      $window.open(imgUrl, '_blank');
      vm.reloadGraph[graph.id] = true;
    }

    function exportCSV(graph)
    {
      var csvContent = "data:text/csv;charset=utf-8," + graph.graphgephicsv;
      var encodedUri = encodeURI(csvContent);
      $window.open(encodedUri, '_blank');
    }

    function exportJSON(graph)
    {
      var jsonContent = "data:application/json;charset=utf-8," + JSON.stringify( graph.graphgephijson );
      var encodedUri = encodeURI(jsonContent);
      $window.open(encodedUri, '_blank');
    }

    function enableOption()
    {
      if ($state.is('app.cctool_graphs_compare') || $state.is('app.cctool_graphs_demo'))
      {
        return false;
      }
      return true;
    }

    // Function to determine the node given (nodeIndex) is a control node.
    function isControlNode(graph, nodeIndex)
    {
      var index = isNaN( parseInt(nodeIndex) ) ? -1 : parseInt(nodeIndex);

      if (!graph.graphanalysed || !graph.graphcontrolconf)
      {
        return false;
      }

      if (graph.graphcontrolconf[vm.selectedConfIndex[graph.id]].indexOf(index) == -1)
      {
        return false;
      }

      return true;
    }

    // ** GRAPH PANEL

    // Function to reset graph's configuration index once selected another graph tab.
    function onGraphTabSelected()
    {
      vm.nodesPanelData = constructNodeData(vm.graphs[vm.selectedGraphIndex]);
      // vm.selectedConfIndex[vm.graphs[graphIndex].id] = 0;
    }

    // Remove any progress bar.
    function clearGraphProgressLinear()
    {
      vm.graphProgressLinear = {active:false, mode:'', value:'', bufferValue:''};
    }

    // Display any progress bar.
    function showGraphProgressLinear()
    {
      vm.graphProgressLinear.active = true;
      vm.graphProgressLinear.mode = 'indeterminate';
    }

    function drawGraph(graph, confTabIndex)
    {
      if (
          $state.is('app.cctool_admin_graphs')
          ||
          $state.is('app.cctool_graphs') 
          ||
          $state.is('app.cctool_graphs_demo') 
         )
      {
        if (vm.graphs[vm.selectedGraphIndex].id === graph.id)
        {
          if (graph.graphanalysed && vm.selectedConfIndex[graph.id] === confTabIndex)
          {
            return true;
          }
          if (!graph.graphanalysed)
          {
            return true;
          }
        }
      }
      if ($state.is('app.cctool_graphs_compare'))
      {
        if (graph.graphanalysed && vm.selectedConfIndex[graph.id] === confTabIndex)
        {
          return true;
        }
        if (!graph.graphanalysed)
        {
          return true;
        }
      }

      return false;
    }

    // Graph Option Buttons
    function onNewGraph()
    {
      $state.go('app.cctool_graphs_new');
    }

    function onGraphAnalyse(graph)
    {
      $log.debug("Called onGraphAnalyse with graph",graph);
      showGraphProgressLinear();
      var params = {id:graph.id};

      var successfulCall1 = function(response)
      {
        $log.debug("Successful onGraphAnalyse call 1 with response",response);
        api.cctool.graph.get(params,successfulCall2,unsuccessfulCall);
      };
      var successfulCall2 = function(response)
      {
        $log.debug("Successful onGraphAnalyse call 2 with response",response);
        clearGraphProgressLinear();
        for(var i in vm.graphs)
        {
          if (vm.graphs[i].id === graph.id)
          {
            vm.graphs[i] = response;
            break;
          }
        }
      };
      var unsuccessfulCall = function(response)
      {
        $log.debug("Unsuccessful onGraphAnalyse call with response",response);
        clearGraphProgressLinear();
        $mdToast.show(
          $mdToast.simple()
          .textContent('Unable to analyse graph!')
          .position(toastPosition)
          .hideDelay(3000)
        );
      };
      api.cctool.graphImplications.get(params,successfulCall1,unsuccessfulCall);
    }

    function onGraphEdit(graph)
    {
      $state.go('app.cctool_graphs_update', { 'graph':graph });
    }

    function onGraphDuplicate(graph)
    {
      $log.debug("Called onGraphDuplicate with graph",graph);
      showGraphProgressLinear();
      var params = {};
      // Gather information to duplicate.
      var duplicatedGraph = JSON.parse(JSON.stringify(graph));
      duplicatedGraph['id'] = Math.random() * (100000 - 10000) + 10000;
      duplicatedGraph['title'] = graph['title'] + '(Copy)';

      var successfulCall1 = function(response)
      {
        $log.debug("Successful onGraphDuplicate call 1 with response",response);
        api.cctool.graphs.get(successfulCall2, unsuccessfulCall);
      };
      var successfulCall2 = function(response)
      {
        $log.debug("Successful onGraphDuplicate call 2 with response",response);
        clearGraphProgressLinear();
        vm.graphs = response.results;
      };
      var unsuccessfulCall = function(response)
      {
        clearGraphProgressLinear();
        $mdToast.show(
          $mdToast.simple()
          .textContent('Unable to duplicate graph!')
          .position(toastPosition)
          .hideDelay(3000)
        );
      };
      var Graph = api.cctool.graphs;
      var newGraph = new Graph(duplicatedGraph);
      newGraph.$save(successfulCall1,unsuccessfulCall);
    }

    function onGraphLayout(graph)
    {
      $log.debug("Called onGraphLayout with graph",graph);
      showGraphProgressLinear();
      var params = {id:graph.id};
      // Gather information to reset.
      var updateGraph = {};
      updateGraph['controlconf']      = graph['controlconf'];;
      updateGraph['controlconfstems'] = graph['controlconfstems'];;
      updateGraph['controllability']  = graph['controllability'];
      updateGraph['importance']       = graph['importance'];
      updateGraph['description']      = graph['description'];
      updateGraph['frequencies']      = graph['frequencies'];
      updateGraph['coordinates']      = JSON.stringify(vm.networks[graph.id].getPositions());
      updateGraph['functions']        = graph['functions'];
      updateGraph['labels']           = graph['labels'];
      updateGraph['moredescription']  = graph['moredescription'];
      updateGraph['structure']        = graph['structure'];
      updateGraph['title']            = graph['title'];

      var successfulCall = function(response)
      {
        $log.debug("Successful onGraphLayout call with response",response);
        clearGraphProgressLinear();
        for(var i in vm.graphs)
        {
          if (vm.graphs[i].id === graph.id)
          {
            updateGraph['id']                    = graph['id'];
            updateGraph['url']                   = graph['url'];
            updateGraph['owner']                 = graph['owner'];
            updateGraph['dateadded']             = graph['dateadded'];
            updateGraph['dateupdated']           = graph['dateupdated'];
            updateGraph['graphanalysed']         = graph['graphanalysed'];
            updateGraph['graphstructure']        = graph['graphstructure'];
            updateGraph['graphnodes']            = graph['graphnodes'];
            updateGraph['graphcontrolconf']      = graph['graphcontrolconf'];
            updateGraph['graphcontrolconfstems'] = graph['graphcontrolconfstems'];
            updateGraph['graphnodefrequencies']  = graph['graphnodefrequencies'];

            vm.graphs[i] = updateGraph;
            break;
          }
        }
      };
      var unsuccessfulCall = function(response)
      {
        $log.debug("Unsuccessful onGraphLayout call with response",response);
        clearGraphProgressLinear();
        $mdToast.show(
          $mdToast.simple()
          .textContent('Unable to save graph layout!')
          .position(toastPosition)
          .hideDelay(3000)
        );
      };
      api.cctool.graph.update(params,updateGraph,successfulCall,unsuccessfulCall);
    }

    function onGraphReset(graph)
    {
      $log.debug("Called onGraphReset with graph",graph);
      showGraphProgressLinear();
      var params = {id:graph.id};
      // Gather information to reset.
      var resetGraph = JSON.parse(JSON.stringify(graph));
      resetGraph['controlconf']      = '';
      resetGraph['controlconfstems'] = '';
      resetGraph['frequencies']      = '';

      var successfulCall1 = function(response)
      {
        $log.debug("Successful onGraphReset call 1 with response",response);
        api.cctool.graph.get(params,successfulCall2,unsuccessfulCall);
      };
      var successfulCall2 = function(response)
      {
        $log.debug("Successful onGraphReset call 2 with response",response);
        clearGraphProgressLinear();
        for(var i in vm.graphs)
        {
          if (vm.graphs[i].id === graph.id)
          {
            vm.graphs[i] = response;
            break;
          }
        }
      };
      var unsuccessfulCall = function(response)
      {
        $log.debug("Unsuccessful onGraphReset call with response",response);
        clearGraphProgressLinear();
        $mdToast.show(
          $mdToast.simple()
          .textContent('Unable to reset graph!')
          .position(toastPosition)
          .hideDelay(3000)
        );
      };
      api.cctool.graph.update(params,resetGraph,successfulCall1,unsuccessfulCall);
    }

    function onGraphRemove(graph)
    {
      $log.debug("Called onGraphRemove with graph",graph);
      showGraphProgressLinear();
      var params = {id:graph.id};

      var successfulCall = function(response)
      {
        $log.debug("Successful onGraphRemove call with response",response);
        clearGraphProgressLinear();
        response.$delete();
        for(var i in vm.graphs)
        {
          if (vm.graphs[i].id === graph.id)
          {
            vm.graphs.splice(i, 1);
            break;
          }
        }
        if (vm.graphs.length < 1)
        {
          $log.debug("Last graph removed, reloading graphs page");
          $state.reload();
        }
      };
      var unsuccessfulCall = function(response)
      {
        $log.debug("Unsuccessful onGraphRemove call with response",response);
        clearGraphProgressLinear();
        $mdToast.show(
          $mdToast.simple()
          .textContent('Unable to remove graph!')
          .position(toastPosition)
          .hideDelay(3000)
        );
      };
      api.cctool.graph.get(params,successfulCall,unsuccessfulCall);
    }

    function onGraphReload(graph)
    {
      vm.reloadGraph[graph.id] = true;
    }

    // Graph Dialogues

    // Control fullscreen graph dialogue.
    function goFullscreenGraph(ev, graph)
    {
      var isSmallScreen = $mdMedia('sm') || $mdMedia('xs');
      $mdDialog.show({
        controller: GraphFullscreenController,
        templateUrl: 'app/cctool/components/graph/dialogs/graph.fullscreen.html',
        parent: angular.element(document.body),
        targetEvent: ev,
        clickOutsideToClose: true,
        locals: { graph            : graph,
                  network          : vm.networks[graph.id],
                  selectedConfIndex: vm.selectedConfIndex,
                  nodeShape        : vm.activeSettings.graphVisualisation.value },
        fullscreen: isSmallScreen
      })
      $scope.$watch(
        function() {
          return $mdMedia('xs') || $mdMedia('sm');
        },
        function(wantsFullScreen) {
          isSmallScreen = true;
        }
      );
    }

    // Control graph key dialogue.
    function showGraphKey(ev)
    {
      var isSmallScreen = $mdMedia('sm') || $mdMedia('xs');
      $mdDialog.show({
        controller: GraphKeyController,
        templateUrl: 'app/cctool/components/graph/dialogs/graph.key.html',
        parent: angular.element(document.body),
        targetEvent: ev,
        clickOutsideToClose: true,
        fullscreen: isSmallScreen
      })
      $scope.$watch(
        function() {
          return $mdMedia('xs') || $mdMedia('sm');
        },
        function(wantsFullScreen) {
          isSmallScreen = true;
        }
      );
    }

    // Control graph key dialogue.
    function showGraphHelp(ev)
    {
      var isSmallScreen = $mdMedia('sm') || $mdMedia('xs');
      $mdDialog.show({
        controller: GraphHelpController,
        templateUrl: 'app/cctool/components/graph/dialogs/graph.help.html',
        parent: angular.element(document.body),
        targetEvent: ev,
        clickOutsideToClose: true,
        fullscreen: isSmallScreen
      })
      $scope.$watch(
        function() {
          return $mdMedia('xs') || $mdMedia('sm');
        },
        function(wantsFullScreen) {
          isSmallScreen = true;
        }
      );
    }

    // Control graph compare dialogue.
    function showGraphCompare(ev)
    {
      var isSmallScreen = $mdMedia('sm') || $mdMedia('xs');
      $mdDialog.show({
        controller: GraphCompareController,
        templateUrl: 'app/cctool/components/graph/dialogs/graph.compare.html',
        parent: angular.element(document.body),
        targetEvent: ev,
        clickOutsideToClose: true,
        locals: { graphs      : vm.graphs,
                  activeIndex : vm.selectedGraphIndex },
        fullscreen: isSmallScreen
      })
      $scope.$watch(
        function() {
          return $mdMedia('xs') || $mdMedia('sm');
        },
        function(wantsFullScreen) {
          isSmallScreen = true;
        }
      );
    }

    // Controller of graph fullscreen dialogue
    function GraphFullscreenController($scope, $mdDialog, $mdMedia, $window, graph, network, selectedConfIndex, nodeShape)
    {
      $scope.$mdMedia          = $mdMedia;
      $scope.windowHeight      = graph.graphanalysed ? angular.element($window)[0].innerHeight - 115 : angular.element($window)[0].innerHeight - 70;
      $scope.graph             = graph;
      $scope.network           = network;
      $scope.selectedConfIndex = selectedConfIndex;
      $scope.nodeShape         = nodeShape;
      $scope.hide = function() {
        $mdDialog.hide();
      };
      $scope.cancel = function() {
        $mdDialog.cancel();
      };
      $scope.answer = function(answer) {
        $mdDialog.hide(answer);
      };
    }

    // Controller of graph key dialogue
    function GraphKeyController($scope, $mdDialog, $mdMedia, cctoolColorsService)
    {
      var colors = cctoolColorsService.cctoolColors;
      $scope.color = colors[5]; // (default to grey)

      $scope.$mdMedia = $mdMedia;
      $scope.hide = function() {
        $mdDialog.hide();
      };
      $scope.cancel = function() {
        $mdDialog.cancel();
      };
      $scope.answer = function(answer) {
        $mdDialog.hide(answer);
      };
    }

    // Controller of graph help dialogue
    function GraphHelpController($scope, $mdDialog, $mdMedia)
    {
      $scope.$mdMedia = $mdMedia;
      $scope.hide = function() {
        $mdDialog.hide();
      };
      $scope.cancel = function() {
        $mdDialog.cancel();
      };
      $scope.answer = function(answer) {
        $mdDialog.hide(answer);
      };
    }

    // Controller of graph compare dialogue
    function GraphCompareController($scope, $mdDialog, $mdMedia, $state, graphs, activeIndex)
    {
      $scope.$mdMedia = $mdMedia;
      $scope.graphs = graphs;
      $scope.activeIndex = activeIndex;
      // Default the first selection to be the active graph we launched the dialogue from.
      $scope.selectedGraphs = [activeIndex.toString()];
      $scope.numberOfCompares = 2;

      $scope.compares = function() {
        return new Array($scope.numberOfCompares);
      };
      $scope.hide = function() {
        $mdDialog.hide();
      };
      $scope.cancel = function() {
        $mdDialog.cancel();
      };
      $scope.answer = function(answer) {
        var graphs = [];
        for (var i in $scope.selectedGraphs)
        {
          graphs.push($scope.graphs[$scope.selectedGraphs[i]]);
        }
        $mdDialog.hide(answer);
        if(graphs)
        {
          $state.go('app.cctool_graphs_compare', { 'graphs':graphs });
        }
      };
    }

    // ** NODES PANEL

    // Function that returns constructed data fro nodes panel as object.
    function constructNodeData(graph)
    {
      // Set the object we are about to return as node data.
      var data =
      {
        title : 'Node Labels',
        table :
        {
          columns:
          [
            {
              title: 'Label'
            },
            {
              title: 'Freq'
            },
            {
              title: 'Contr'
            },
            {
              title: 'Imp'
            }
          ],
          rows:[]
        },
      };

      // Split the values to be ready for each node.
      var labels = graph.labels.split(',');
      var numberOfSets = graph.graphnodefrequencies[0];
      var frequencies = graph.graphnodefrequencies[1] || [];
      var functions = graph.functions.split(' ');
      var controllabilities = graph.controllability.split(' ');
      var importances = graph.importance.split(' ');

      for (var node in graph.graphnodes)
      {
        var label = labels[node];
        var frequency = frequencies[node] || 0;
        var func = functions[node];
        var controllability = controllabilities[node],
          controllabilityClasses = '';
        var importance = importances[node],
          importanceClasses = '';

        if (frequency == 0)
        {
          frequency = '-';
        }
        else
        {
          frequency = ((frequency/numberOfSets) * 100).toFixed(0) + '%';
        }

        switch(func) {
          case 'L':
            func = 'Linear'; 
            break;
          case 'S':
            func = 'Sigmoid'; 
            break;
        }

        switch(controllability) {
          case '0':
            controllability = '<span style="display:none">0</span>Neutral';
            controllabilityClasses = 'black-label';
            break;
          case 'E':
            controllability = '<span style="display:none">1</span>Easy';
            controllabilityClasses = 'green-label';
            break;
          case 'M':
            controllability = '<span style="display:none">2</span>Med.';
            controllabilityClasses = 'amber-label';
            break;
          case 'H':
            controllability = '<span style="display:none">3</span>Hard';
            controllabilityClasses = 'red-label';
            break;
        }

        switch(importance) {
          case '0':
            importance = '<span style="display:none">0</span>None';
            importanceClasses = 'black-label';
            break;
          case 'L':
            importance = '<span style="display:none">1</span>Low';
            importanceClasses = 'black-label';
            break;
          case 'H':
            importance = '<span style="display:none">2</span>High';
            importanceClasses = 'black-label';
            break;
        }

        var nodeData =
        [
          { 'index' : node, 'value' : label,           'classes': 'word-break' },
          { 'index' : node, 'value' : frequency,       'classes': 'word-break' },
          { 'index' : node, 'value' : controllability, 'classes': controllabilityClasses },
          { 'index' : node, 'value' : importance,      'classes': importanceClasses }
        ]

        data.table.rows.push(nodeData);
      }

      return data;
    }
    
    // ** STEMS PANEL

    // Stems Dialogues

    // Control stems fullscreen dialogue.
    function goFullscreenStems(ev)
    {
      var isSmallScreen = $mdMedia('sm') || $mdMedia('xs');
      $mdDialog.show({
        controller: StemsFullscreenController,
        templateUrl: 'app/cctool/components/stems/dialogs/stems.fullscreen.html',
        parent: angular.element(document.body),
        targetEvent: ev,
        clickOutsideToClose: true,
        locals: { graph            : vm.graphs[vm.selectedGraphIndex],
                  selectedConfIndex: vm.selectedConfIndex,
                  nodeShape        : vm.activeSettings.graphVisualisation.value },
        fullscreen: isSmallScreen
      })
      $scope.$watch(
        function() {
          return $mdMedia('xs') || $mdMedia('sm');
        },
        function(wantsFullScreen) {
          isSmallScreen = true;
        }
      );
    }

    // Control stems key dialogue.
    function showStemsKey(ev)
    {
      var isSmallScreen = $mdMedia('sm') || $mdMedia('xs');
      $mdDialog.show({
        controller: StemsKeyController,
        templateUrl: 'app/cctool/components/stems/dialogs/stems.key.html',
        parent: angular.element(document.body),
        targetEvent: ev,
        clickOutsideToClose: true,
        fullscreen: isSmallScreen
      })
      $scope.$watch(
        function() {
          return $mdMedia('xs') || $mdMedia('sm');
        },
        function(wantsFullScreen) {
          isSmallScreen = true;
        }
      );
    }

    // Control stems help dialogue.
    function showStemsHelp(ev)
    {
      var isSmallScreen = $mdMedia('sm') || $mdMedia('xs');
      $mdDialog.show({
        controller: StemsHelpController,
        templateUrl: 'app/cctool/components/stems/dialogs/stems.help.html',
        parent: angular.element(document.body),
        targetEvent: ev,
        clickOutsideToClose: true,
        fullscreen: isSmallScreen
      })
      $scope.$watch(
        function() {
          return $mdMedia('xs') || $mdMedia('sm');
        },
        function(wantsFullScreen) {
          isSmallScreen = true;
        }
      );
    }

    // Controller of stems fullscreen dialogue
    function StemsFullscreenController($scope, $mdDialog, $mdMedia, graph, selectedConfIndex, nodeShape)
    {
      $scope.$mdMedia          = $mdMedia;
      $scope.graph             = graph;
      $scope.selectedConfIndex = selectedConfIndex;
      $scope.nodeShape         = nodeShape;
      $scope.hide = function() {
        $mdDialog.hide();
      };
      $scope.cancel = function() {
        $mdDialog.cancel();
      };
      $scope.answer = function(answer) {
        $mdDialog.hide(answer);
      };
    }

    // Controller of stems key dialogue
    function StemsKeyController($scope, $mdDialog, $mdMedia, cctoolColorsService)
    {
      var colors = cctoolColorsService.cctoolColors;
      $scope.color = colors[5]; // (default to grey)

      $scope.$mdMedia = $mdMedia;
      $scope.hide = function() {
        $mdDialog.hide();
      };
      $scope.cancel = function() {
        $mdDialog.cancel();
      };
      $scope.answer = function(answer) {
        $mdDialog.hide(answer);
      };
    }

    // Controller of stems help dialogue
    function StemsHelpController($scope, $mdDialog, $mdMedia)
    {
      $scope.$mdMedia = $mdMedia;
      $scope.hide = function() {
        $mdDialog.hide();
      };
      $scope.cancel = function() {
        $mdDialog.cancel();
      };
      $scope.answer = function(answer) {
        $mdDialog.hide(answer);
      };
    }

  }

})();